"""
Bot de Telegram para consultar horarios en tiempo real del Metro de Granada,
gestionar favoritas y alertas de llegada con selecci√≥n de umbral y direcci√≥n,
con notificaciones autom√°ticas y visualizaci√≥n de la situaci√≥n de los metros.

Licencia: GNU General Public License v3.0
Autor: Jorge Chamorro Padial
"""

import os
import json
import requests
import logging

from dotenv import load_dotenv
from telegram import (
    Update,
    InlineKeyboardButton,
    InlineKeyboardMarkup,
    ReplyKeyboardMarkup,
    KeyboardButton
)
from telegram.ext import (
    ApplicationBuilder,
    CommandHandler,
    CallbackQueryHandler,
    MessageHandler,
    ContextTypes,
    filters
)

# ‚îÄ‚îÄ Configuraci√≥n b√°sica ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
load_dotenv()
TOKEN = os.getenv("TELEGRAM_TOKEN")
if not TOKEN:
    raise ValueError("‚ùå TELEGRAM_TOKEN no definido en .env")

API_BASE       = "https://movgr.apis.mianfg.me"
FAVORITOS_FILE = "favoritos.json"
ALERTAS_FILE   = "alertas.json"
NUM_TRENES     = 4

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# ‚îÄ‚îÄ Datos en memoria ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
favoritos = {}  # user_id (int) ‚Üí set(parada_id:str)
paradas    = {}  # parada_id (str) ‚Üí nombre (str)
# alertas: user_id (str) ‚Üí list of [parada_id (str), umbral (int), direccion (str)]
alertas    = {}

# ‚îÄ‚îÄ Teclado persistente (reply keyboard) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
MAIN_MENU = ReplyKeyboardMarkup(
    keyboard=[
        [KeyboardButton("üîç Ver paradas"), KeyboardButton("‚≠ê Favoritas")],
        [KeyboardButton("üöÜ Situaci√≥n de los metros"), KeyboardButton("üìÑ Informaci√≥n")]
    ],
    resize_keyboard=True,
    one_time_keyboard=False
)

# ‚îÄ‚îÄ Persistencia JSON ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
def cargar_json(ruta, por_defecto):
    if os.path.exists(ruta):
        with open(ruta, "r", encoding="utf-8") as f:
            return json.load(f)
    return por_defecto

def guardar_json(ruta, datos):
    with open(ruta, "w", encoding="utf-8") as f:
        json.dump(datos, f, ensure_ascii=False, indent=2)

def cargar_favoritos():
    global favoritos
    tmp = cargar_json(FAVORITOS_FILE, {})
    favoritos = {int(k): set(v) for k, v in tmp.items()}

def guardar_favoritos():
    tmp = {str(k): list(v) for k, v in favoritos.items()}
    guardar_json(FAVORITOS_FILE, tmp)

def cargar_alertas():
    global alertas
    alertas = cargar_json(ALERTAS_FILE, {})

def guardar_alertas():
    guardar_json(ALERTAS_FILE, alertas)

# ‚îÄ‚îÄ Carga de paradas desde la API ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
def cargar_paradas():
    global paradas
    resp = requests.get(f"{API_BASE}/metro/paradas")
    resp.raise_for_status()
    datos = resp.json()
    paradas = {p["id"]: p["nombre"] for p in datos}

# ‚îÄ‚îÄ Env√≠o/actualizaci√≥n del men√∫ persistente ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
async def enviar_mensaje_menu(obj, context: ContextTypes.DEFAULT_TYPE):
    """
    Env√≠a o actualiza el men√∫ principal en la parte inferior.
    obj puede ser Update o CallbackQuery.
    """
    # Extraer chat_id
    if hasattr(obj, "effective_chat") and obj.effective_chat:
        chat_id = obj.effective_chat.id
    else:
        # CallbackQuery
        chat_id = obj.message.chat.id

    old = context.user_data.get("menu_msg_id")
    if old:
        try:
            await context.bot.delete_message(chat_id=chat_id, message_id=old)
        except:
            pass

    sent = await context.bot.send_message(
        chat_id=chat_id,
        text="¬øQu√© deseas hacer?",
        reply_markup=MAIN_MENU
    )
    context.user_data["menu_msg_id"] = sent.message_id

# ‚îÄ‚îÄ Handlers ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """
    /start o 'üîç Ver paradas': muestra la lista de paradas.
    """
    items = list(paradas.items())
    botones = []
    for i in range(0, len(items), 2):
        fila = [
            InlineKeyboardButton(nombre, callback_data=f"ver:{pid}")
            for pid, nombre in items[i:i+2]
        ]
        botones.append(fila)

    await update.message.reply_text(
        "Selecciona una parada para ver los pr√≥ximos trenes:",
        reply_markup=InlineKeyboardMarkup(botones)
    )
    await enviar_mensaje_menu(update, context)

async def handle_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """
    Procesa callbacks inline: ver llegada, toggle favorito, eliminar favorito,
    iniciar alerta, seleccionar umbral y direcci√≥n.
    """
    query = update.callback_query
    await query.answer()
    user_id = query.from_user.id
    parts = query.data.split(":")

    action = parts[0]
    if action == "ver":
        return await ver_parada_detalle(query, context, parts[1])
    if action == "toggle":
        return await toggle_fav_callback(query, context, parts[1])
    if action == "del":
        return await del_fav_callback(query, context, parts[1])
    if action == "setalert":
        pid = parts[1]
        teclado = [[
            InlineKeyboardButton("2 min", callback_data=f"alertthr:{pid}:2"),
            InlineKeyboardButton("5 min", callback_data=f"alertthr:{pid}:5"),
            InlineKeyboardButton("8 min", callback_data=f"alertthr:{pid}:8"),
        ]]
        await query.edit_message_text(
            f"‚è∞ Elige umbral para alerta en *{paradas.get(pid)}*:",
            parse_mode="Markdown",
            reply_markup=InlineKeyboardMarkup(teclado)
        )
        return
    if action == "alertthr":
        pid, umbral = parts[1], parts[2]
        teclado = [[
            InlineKeyboardButton("Hacia Armilla", callback_data=f"alertdir:{pid}:{umbral}:Armilla"),
            InlineKeyboardButton("Hacia Albolote", callback_data=f"alertdir:{pid}:{umbral}:Albolote"),
        ]]
        await query.edit_message_text(
            f"üö© Elige sentido para alerta de *{paradas.get(pid)}* ‚â§{umbral}‚ÄØmin:",
            parse_mode="Markdown",
            reply_markup=InlineKeyboardMarkup(teclado)
        )
        return
    if action == "alertdir":
        pid, umbral, direccion = parts[1], parts[2], parts[3]
        alertas.setdefault(str(user_id), []).append([pid, int(umbral), direccion])
        guardar_alertas()
        await query.edit_message_text(
            f"‚úÖ Alerta creada: *{paradas.get(pid)}* ‚Üí *{direccion}* en ‚â§{umbral}‚ÄØmin.",
            parse_mode="Markdown"
        )
        await enviar_mensaje_menu(query, context)
        return

# ‚îÄ‚îÄ Funciones de parada ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
async def ver_parada_detalle(q, context, pid: str):
    """
    Muestra pr√≥ximos trenes e incluye botones Favorita y Alerta.
    """
    nombre = paradas.get(pid, pid)
    r = requests.get(f"{API_BASE}/metro/llegadas/{pid}")
    if r.status_code != 200:
        texto = f"‚ùå Error al consultar {nombre}."
    else:
        info = r.json()
        if not info.get("proximos"):
            texto = f"üöâ *{nombre}*\n_No hay trenes pr√≥ximos._"
        else:
            lines = [f"üöâ *{nombre}*"]
            for t in info["proximos"][:NUM_TRENES]:
                lines.append(f"‚Ä¢ En {t['minutos']}‚ÄØmin ‚Üí {t['direccion']}")
            texto = "\n".join(lines)

    fav = pid in favoritos.get(q.from_user.id, set())
    btn_fav   = InlineKeyboardButton("‚≠ê Quitar favorita" if fav else "‚ûï A√±adir favorita",
                                     callback_data=f"toggle:{pid}")
    btn_alert = InlineKeyboardButton("‚è∞ Alerta", callback_data=f"setalert:{pid}")

    await q.edit_message_text(
        texto + ("\n‚≠ê Favorita" if fav else ""),
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup([[btn_fav, btn_alert]])
    )
    await enviar_mensaje_menu(q, context)

async def toggle_fav_callback(q, context, pid: str):
    """A√±ade o quita una parada de favoritas."""
    user = q.from_user.id
    favs = favoritos.setdefault(user, set())
    if pid in favs:
        favs.remove(pid)
        msg = "‚ùå Parada eliminada de favoritas."
    else:
        if len(favs) >= 5:
            msg = "‚ö†Ô∏è L√≠mite de 5 favoritas alcanzado."
        else:
            favs.add(pid)
            msg = "‚úÖ Parada a√±adida a favoritas."
    guardar_favoritos()
    await q.edit_message_text(msg, reply_markup=MAIN_MENU)

async def del_fav_callback(q, context, pid: str):
    """Elimina una parada de favoritas."""
    user = q.from_user.id
    favoritos.get(user, set()).discard(pid)
    guardar_favoritos()
    await q.edit_message_text("‚ùå Favorita eliminada.", reply_markup=MAIN_MENU)

async def favoritas_cmd(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Muestra las paradas favoritas."""
    user = update.effective_user.id
    favs = favoritos.get(user, set())
    if not favs:
        await update.message.reply_text("No tienes favoritas a√∫n.", reply_markup=MAIN_MENU)
        return
    for pid in favs:
        nombre = paradas.get(pid, pid)
        r = requests.get(f"{API_BASE}/metro/llegadas/{pid}")
        if r.status_code != 200:
            await update.message.reply_text(f"{nombre}: ‚ö†Ô∏è Error", reply_markup=MAIN_MENU)
        else:
            info = r.json()
            lines = [f"üöâ *{nombre}*"]
            for t in info.get("proximos", [])[:2]:
                lines.append(f"‚Ä¢ En {t['minutos']}‚ÄØmin ‚Üí {t['direccion']}")
            btn = InlineKeyboardButton(f"‚ùå Eliminar {nombre}", callback_data=f"del:{pid}")
            await update.message.reply_text(
                "\n".join(lines),
                parse_mode="Markdown",
                reply_markup=InlineKeyboardMarkup([[btn]])
            )
    await enviar_mensaje_menu(update, context)

# ‚îÄ‚îÄ Situaci√≥n de los metros ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
async def estado_textual(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """
    Muestra la situaci√≥n de los metros en dos columnas:
    üöá si tren < 3‚ÄØmin, solo minutos si ‚â• 3‚ÄØmin, ‚Äî si no hay tren.
    """
    chat_id = update.effective_chat.id
    resp = requests.get(f"{API_BASE}/metro/llegadas")
    resp.raise_for_status()
    datos = resp.json()
    lleg = {e["parada"]["id"]: e.get("proximos", []) for e in datos}
    orden = list(paradas.keys())

    teclado = []
    for pid in orden:
        nombre = paradas.get(pid, pid)
        prox = lleg.get(pid, [])
        t_arm = next((t["minutos"] for t in prox if t["direccion"] == "Armilla"), None)
        t_alb = next((t["minutos"] for t in prox if t["direccion"] == "Albolote"), None)
        txt_a = f"{nombre} {'üöá' if t_arm is not None and t_arm < 3 else ''}{t_arm or '‚Äî'}m"
        txt_b = f"{nombre} {'üöá' if t_alb is not None and t_alb < 3 else ''}{t_alb or '‚Äî'}m"
        teclado.append([
            InlineKeyboardButton(txt_a, callback_data=f"ver:{pid}"),
            InlineKeyboardButton(txt_b, callback_data=f"ver:{pid}")
        ])

    await context.bot.send_message(
        chat_id,
        "üöÜ *Situaci√≥n de los metros*\n"
        "_Izquierda: Hacia Armilla_  |  _Derecha: Hacia Albolote_\n",
        parse_mode="Markdown"
    )
    await context.bot.send_message(
        chat_id,
        "Pulsa una parada para ver detalles:",
        reply_markup=InlineKeyboardMarkup(teclado)
    )
    await enviar_mensaje_menu(update, context)

# ‚îÄ‚îÄ Info ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
async def info_cmd(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Muestra informaci√≥n del bot."""
    await update.message.reply_text(
        "üìÑ *Informaci√≥n del bot*\n\n"
        "üë§ Jorge Chamorro Padial\n"
        "üìù GNU GPL v3.0\n"
        "üôè Gracias a la API MovGR\n"
        "üíª https://github.com/jorgechp/grana-metro-bot",
        parse_mode="Markdown",
        disable_web_page_preview=True,
        reply_markup=MAIN_MENU
    )
    await enviar_mensaje_menu(update, context)

# ‚îÄ‚îÄ JobQueue: comprobaci√≥n de alertas (se dispara una sola vez) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
async def check_alertas(context: ContextTypes.DEFAULT_TYPE):
    mods = False
    nuevos = {}
    for user, subs in alertas.items():
        viva = []
        for pid, um, dirc in subs:
            try:
                r = requests.get(f"{API_BASE}/metro/llegadas/{pid}")
                r.raise_for_status()
                prox = r.json().get("proximos", [])
                if prox and prox[0]["direccion"] == dirc and prox[0]["minutos"] <= um:
                    await context.bot.send_message(
                        chat_id=int(user),
                        text=(
                            f"üö® *Alerta*: {paradas.get(pid)} ‚Üí {dirc} en "
                            f"{prox[0]['minutos']}‚ÄØmin)."
                        ),
                        parse_mode="Markdown"
                    )
                    mods = True
                    continue
            except:
                pass
            viva.append([pid, um, dirc])
        if viva:
            nuevos[user] = viva
        else:
            mods = True
    if mods:
        alertas.clear()
        alertas.update(nuevos)
        guardar_alertas()

# ‚îÄ‚îÄ Manejo de texto del men√∫ persistente ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
async def mensaje_menu(update: Update, context: ContextTypes.DEFAULT_TYPE):
    txt = update.message.text
    if txt == "üîç Ver paradas":
        await start(update, context)
    elif txt == "‚≠ê Favoritas":
        await favoritas_cmd(update, context)
    elif txt == "üöÜ Situaci√≥n de los metros":
        await estado_textual(update, context)
    elif txt == "üìÑ Informaci√≥n":
        await info_cmd(update, context)

# ‚îÄ‚îÄ Arranque del bot ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
if __name__ == "__main__":
    cargar_favoritos()
    cargar_paradas()
    cargar_alertas()

    app = ApplicationBuilder().token(TOKEN).build()

    # Comprobaci√≥n de alertas cada 30 segundos, primer disparo inmediato
    app.job_queue.run_repeating(check_alertas, interval=30, first=0)

    # Registramos handlers
    app.add_handler(CommandHandler("start", start))
    app.add_handler(CallbackQueryHandler(handle_callback))
    app.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, mensaje_menu))

    logger.info("Bot arrancado. Esperando eventos‚Ä¶")
    app.run_polling()
